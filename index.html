<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D War Game - Final Build</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; font-family: 'Inter', sans-serif; background-color: #111827; color: white; overflow: hidden; }
        #game-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; cursor: crosshair; }
        .screen { display: flex; flex-direction: column; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); backdrop-filter: blur(10px); z-index: 10; overflow-y: auto; padding: 1rem; }
        .hidden { display: none !important; }
        .card { transition: transform 0.3s, box-shadow 0.3s; border: 2px solid transparent; }
        .card:hover { transform: translateY(-5px); box-shadow: 0 8px 15px rgba(0, 255, 255, 0.15); }
        .card.selected { border-color: #0891B2; transform: translateY(-2px) scale(1.02); }
        .char-image { width: 150px; height: 150px; margin: 0 auto 1rem; border-radius: 50%; border: 4px solid #4B5563; object-fit: cover; }
        .card.selected .char-image { border-color: #0891B2; }
        #hud { position: absolute; bottom: 20px; left: 20px; color: white; font-size: 20px; text-shadow: 2px 2px 4px #000000; z-index: 5; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; border: 2px solid white; border-radius: 50%; transform: translate(-50%, -50%); z-index: 5; }
        #instructions { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center; background-color: rgba(0,0,0,0.5); padding: 20px; border-radius: 10px; z-index: 20; }
        #mobile-controls { position: fixed; bottom: 0; left: 0; width: 100%; height: 100%; z-index: 6; pointer-events: none;}
        .joystick-base { position: absolute; bottom: 20px; left: 20px; width: 100px; height: 100px; background-color: rgba(255,255,255,0.2); border-radius: 50%; pointer-events: auto; }
        .joystick-nub { position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; background-color: rgba(255,255,255,0.4); border-radius: 50%; transform: translate(-50%, -50%); }
        .action-button { position: absolute; bottom: 20px; width: 70px; height: 70px; background-color: rgba(255, 80, 80, 0.4); border: 2px solid rgba(255, 80, 80, 0.6); border-radius: 50%; pointer-events: auto; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold; font-size: 12px; }
        #shoot-btn { right: 20px; }
        #sprint-btn { right: 110px; bottom: 70px; width: 50px; height: 50px; background-color: rgba(80, 255, 80, 0.4); border-color: rgba(80, 255, 80, 0.6); }
        #look-area { position: absolute; top: 0; right: 0; width: 50%; height: 100%; pointer-events: auto; }
        #rotate-device-screen { z-index: 9999; }
        @media (orientation: landscape) { #rotate-device-screen { display: none !important; } }
        @media (orientation: portrait) { #start-menu, #login-screen, #game-over-screen, #game-container, #hud, #mobile-controls, #crosshair, #instructions { display: none !important; } }
    </style>
</head>
<body>
    <!-- UI Elements -->
    <div id="rotate-device-screen" class="screen">
        <div class="text-center">
             <svg class="mx-auto h-24 w-24 text-white animate-pulse" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M10.5 1.5H8.25A2.25 2.25 0 0 0 6 3.75v16.5a2.25 2.25 0 0 0 2.25 2.25h7.5A2.25 2.25 0 0 0 18 20.25V3.75a2.25 2.25 0 0 0-2.25-2.25H13.5m-3 0V3h3V1.5m-3 0h3m-3 18.75h3" />
            </svg>
            <h1 class="text-3xl font-bold mt-4">Putar Perangkat Anda</h1>
            <p class="text-lg mt-2 text-gray-300">Game ini dirancang untuk dimainkan dalam mode horizontal.</p>
        </div>
    </div>

    <div id="login-screen" class="screen hidden">
        <div class="w-full max-w-md bg-gray-800 p-8 rounded-lg shadow-2xl">
            <h1 class="text-3xl font-bold mb-6 text-cyan-300 text-center">Login Pemain</h1>
            <div class="space-y-4">
                <input id="email-input" type="email" placeholder="Email" class="w-full p-3 bg-gray-700 rounded border border-gray-600 focus:outline-none focus:border-cyan-500">
                <input id="password-input" type="password" placeholder="Password" class="w-full p-3 bg-gray-700 rounded border border-gray-600 focus:outline-none focus:border-cyan-500">
            </div>
            <p id="auth-error" class="text-red-500 text-center h-6 mt-4"></p>
            <div class="mt-6 flex space-x-4">
                <button id="login-btn" class="w-full bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-3 rounded-lg transition duration-300">Masuk</button>
                <button id="register-btn" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 rounded-lg transition duration-300">Daftar</button>
            </div>
        </div>
    </div>

    <div id="start-menu" class="screen hidden">
        <div class="w-full max-w-screen-xl mx-auto flex flex-col lg:flex-row items-center justify-center lg:justify-between h-full gap-8">
            <!-- Left Column: Character Selection -->
            <div class="w-full lg:w-3/5">
                <h1 class="text-5xl font-bold mb-2 text-cyan-300 animate-pulse text-center">3D WAR ZONE</h1>
                <p class="text-xl mb-6 text-gray-300 text-center">Pilih Karakter</p>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div id="char-assault" class="card character-card bg-gray-800 p-4 rounded-lg cursor-pointer selected"><img src="https://placehold.co/150x150/2d3748/e2e8f0?text=Assault" alt="Assault" class="char-image"><h3 class="text-xl font-bold text-center">Assault</h3></div>
                    <div id="char-sniper" class="card character-card bg-gray-800 p-4 rounded-lg cursor-pointer"><img src="https://placehold.co/150x150/2d3748/e2e8f0?text=Sniper" alt="Sniper" class="char-image"><h3 class="text-xl font-bold text-center">Sniper</h3></div>
                    <div id="char-heavy" class="card character-card bg-gray-800 p-4 rounded-lg cursor-pointer"><img src="https://placehold.co/150x150/2d3748/e2e8f0?text=Heavy" alt="Heavy" class="char-image"><h3 class="text-xl font-bold text-center">Heavy</h3></div>
                </div>
            </div>
            <!-- Right Column: Arena, Leaderboard, Start -->
            <div class="w-full lg:w-2/5 flex flex-col gap-6">
                 <div class="flex items-center justify-center gap-4 bg-gray-900/50 p-2 rounded-lg">
                    <div>
                        <p class="text-gray-400 text-sm">Pemain:</p>
                        <p id="player-id" class="text-cyan-300 font-mono text-xs">Memuat...</p>
                    </div>
                    <button id="main-logout-btn" class="bg-red-600 hover:bg-red-500 text-white text-xs font-bold py-1 px-3 rounded-lg">Logout</button>
                </div>
                <div>
                    <h2 class="text-2xl font-semibold mb-3 text-center">Pilih Arena</h2>
                    <div class="flex justify-center space-x-4">
                        <button id="map-forest" class="map-btn bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-6 rounded-lg border-4 border-green-500">Hutan</button>
                        <button id="map-city" class="map-btn bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-lg border-4 border-transparent">Gedung</button>
                        <button id="map-snow" class="map-btn bg-blue-300 hover:bg-blue-200 text-black font-bold py-3 px-6 rounded-lg border-4 border-transparent">Salju</button>
                    </div>
                </div>
                <div id="leaderboard" class="w-full bg-gray-900/50 p-4 rounded-lg"><h2 class="text-2xl font-semibold mb-2 text-center text-cyan-300">Papan Peringkat</h2><div id="leaderboard-list" class="space-y-1 text-sm"><p class="text-center text-gray-400">Memuat...</p></div></div>
                <button id="start-game-btn" class="w-full bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-4 rounded-lg text-2xl transition duration-300 transform hover:scale-105">MULAI PERANG</button>
            </div>
        </div>
    </div>

    <div id="game-over-screen" class="screen hidden"><div class="w-full max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12 text-center"><h1 class="text-7xl font-bold mb-4 text-red-500">GAME OVER</h1><p class="text-3xl mb-10 text-gray-300">Kamu telah dikalahkan.</p><button id="restart-btn" class="bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-5 px-10 rounded-lg text-3xl transition duration-300 transform hover:scale-110">KEMBALI KE MENU</button></div></div>
    
    <div id="game-container"></div>
    <div id="hud" class="hidden"><div id="health-display"></div><div id="ammo-display"></div><div id="enemy-display"></div></div>
    <div id="crosshair" class="hidden"></div>
    <div id="instructions" class="hidden">
        <p class="text-2xl font-bold mb-2">PERMAINAN DIJEDA</p>
        <p>Klik layar untuk melanjutkan</p>
        <div class="mt-4 text-sm bg-black bg-opacity-30 p-2 rounded">
            <p>W, A, S, D: Bergerak</p>
            <p>Shift: Berlari</p>
            <p>Mouse: Melihat</p>
            <p>Klik Kiri: Menembak</p>
        </div>
    </div>
    
    <!-- Mobile Controls -->
    <div id="mobile-controls" class="hidden">
        <div id="look-area"></div>
        <div class="joystick-base">
            <div class="joystick-nub"></div>
        </div>
        <button id="shoot-btn" class="action-button">TEMBAK</button>
        <button id="sprint-btn" class="action-button">LARI</button>
    </div>

    <script type="importmap">{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } }</script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, collection, addDoc, getDocs, query, limit } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        const firebaseConfig = { apiKey: "AIzaSyDJMcKXB4Q8MLJi6-EANHLnQrYGzLrEsIU", authDomain: "game-war-408dd.firebaseapp.com", projectId: "game-war-408dd", storageBucket: "game-war-408dd.appspot.com", messagingSenderId: "842819589067", appId: "1:842819589067:web:fad1a942bca1d882bb9c4e" };

        const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

        class GameEngine {
            constructor(endGameCallback) {
                this.endGameCallback = endGameCallback;
                this.state = {
                    scene: null, camera: null, renderer: null, controls: null, player: null, clock: null,
                    animationFrameId: null, weaponModel: null, snowParticles: null,
                    enemies: [], bullets: [], mapObjects: [], keys: {},
                    playerHealth: 100, currentAmmo: 30, maxAmmo: 30, totalEnemies: 10, remainingEnemies: 10,
                    touchLook: { x: 0, y: 0, lastX: 0, lastY: 0, active: false }
                };
            }

            start(mapType, characterType) {
                this.state.scene = new THREE.Scene();
                this.state.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.state.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.state.renderer.setSize(window.innerWidth, window.innerHeight);
                this.state.renderer.setPixelRatio(window.devicePixelRatio);
                this.state.renderer.shadowMap.enabled = true;
                this.state.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                document.getElementById('game-container').appendChild(this.state.renderer.domElement);
                
                if (!isMobile) {
                    this.state.controls = new PointerLockControls(this.state.camera, this.state.renderer.domElement);
                    this.state.player = this.state.controls.getObject();
                } else {
                    this.state.player = this.state.camera;
                }
                this.state.scene.add(this.state.player);
                this.resetPlayerState();

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                this.state.scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
                directionalLight.position.set(100, 100, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.state.scene.add(directionalLight);
                
                this.state.weaponModel = this.createPlayerWeaponModel(characterType);
                this.state.camera.add(this.state.weaponModel);

                this.createMap(mapType);
                this.spawnEnemies(this.state.totalEnemies);

                this.addGameEventListeners();
                if (!isMobile) {
                    this.state.controls.lock();
                }

                this.animate();
            }

            destroy() {
                if (this.state.animationFrameId) cancelAnimationFrame(this.state.animationFrameId);
                this.removeGameEventListeners();
                if (this.state.controls) this.state.controls.dispose();
                
                if (this.state.scene) {
                    this.state.scene.traverse(object => {
                        if (object.geometry) object.geometry.dispose();
                        if (object.material) {
                            if (Array.isArray(object.material)) object.material.forEach(m => m.dispose());
                            else object.material.dispose();
                        }
                    });
                }
                
                if (this.state.renderer) {
                    this.state.renderer.dispose();
                    if (this.state.renderer.domElement && this.state.renderer.domElement.parentElement) {
                        this.state.renderer.domElement.parentElement.removeChild(this.state.renderer.domElement);
                    }
                }
            }

            resetPlayerState() {
                this.state.playerHealth = 100;
                this.state.currentAmmo = this.state.maxAmmo;
                this.state.remainingEnemies = this.state.totalEnemies;
                this.state.player.position.set(0, 1.8, 5);
                this.state.keys = {};
                this.state.clock = new THREE.Clock();
            }
            
            createMap(mapType) {
                let groundColor, obs1, obs2, bgColor, fogColor;
                switch (mapType) {
                    case 'city': [groundColor, obs1, obs2, bgColor, fogColor] = [0x4a5568, 0x2d3748, 0x1a202c, 0x718096, 0x718096]; break;
                    case 'snow': [groundColor, obs1, obs2, bgColor, fogColor] = [0xe2e8f0, 0xf1f5f9, 0xf8fafc, 0xa0aec0, 0xa0aec0]; break;
                    default: [groundColor, obs1, obs2, bgColor, fogColor] = [0x2f855a, 0x8B4513, 0x276749, 0x4fd1c5, 0x4fd1c5]; break;
                }
                this.state.scene.background = new THREE.Color(bgColor);
                this.state.scene.fog = new THREE.Fog(fogColor, 50, 250);
                const ground = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), new THREE.MeshStandardMaterial({ color: groundColor }));
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.state.scene.add(ground);
                this.state.mapObjects.push(ground);
                
                if(mapType === 'city') {
                    for (let i = 0; i < 80; i++) {
                        const x = Math.random() * 400 - 200, z = Math.random() * 400 - 200;
                        if (Math.hypot(x,z) < 50) continue;
                        const height = Math.random() * 60 + 20;
                        const width = Math.random() * 15 + 10;
                        const depth = Math.random() * 15 + 10;
                        const building = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), new THREE.MeshStandardMaterial({color: Math.random() > 0.5 ? obs1 : obs2, roughness: 0.8, metalness: 0.2}));
                        building.position.set(x, height/2, z);
                        building.castShadow = true;
                        building.receiveShadow = true;
                        this.state.scene.add(building);
                        this.state.mapObjects.push(building);
                    }
                     for (let i = 0; i < 30; i++) {
                        const wall = new THREE.Mesh(new THREE.BoxGeometry(Math.random()*10+5, 3, 0.5), new THREE.MeshStandardMaterial({color: 0x4a5568}));
                        wall.position.set(Math.random() * 300 - 150, 1.5, Math.random() * 300 - 150);
                        wall.rotation.y = Math.random() * Math.PI;
                        this.state.scene.add(wall);
                        this.state.mapObjects.push(wall);
                     }
                } else if (mapType === 'snow') {
                    for (let i = 0; i < 150; i++) {
                        const x = Math.random() * 600 - 300, z = Math.random() * 600 - 300;
                        if (Math.hypot(x, z) < 50) continue;
                        const height = Math.random() * 15 + 5;
                        const radius = Math.random() * 0.5 + 0.2;
                        const tree = new THREE.Mesh(new THREE.ConeGeometry(radius * 3, height, 8), new THREE.MeshStandardMaterial({ color: obs1 }));
                        tree.position.set(x, height / 2, z);
                        tree.castShadow = true;
                        this.state.scene.add(tree);
                        this.state.mapObjects.push(tree);
                    }
                    this.createSnowfall();
                } else { // Forest
                     for (let i = 0; i < 200; i++) {
                        const x = Math.random() * 800 - 400, z = Math.random() * 800 - 400;
                        if (Math.hypot(x,z) < 50) continue;
                        const height = Math.random() * 25 + 10;
                        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.8, height, 8), new THREE.MeshStandardMaterial({color: obs1}));
                        trunk.position.set(x, height/2, z);
                        const foliage = new THREE.Mesh(new THREE.SphereGeometry(Math.random() * 4 + 3, 8, 6), new THREE.MeshStandardMaterial({color: obs2}));
                        foliage.position.y = height;
                        trunk.add(foliage);
                        trunk.castShadow = true;
                        this.state.scene.add(trunk);
                        this.state.mapObjects.push(trunk);
                    }
                }
            }

            createSnowfall() {
                const vertices = [];
                for (let i = 0; i < 15000; i++) {
                    const x = Math.random() * 2000 - 1000;
                    const y = Math.random() * 500 - 250;
                    const z = Math.random() * 2000 - 1000;
                    vertices.push(x, y, z);
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, transparent: true, opacity: 0.8 });
                this.state.snowParticles = new THREE.Points(geometry, material);
                this.state.scene.add(this.state.snowParticles);
            }

            spawnEnemies(count) {
                for (let i = 0; i < count; i++) {
                    const enemyGroup = new THREE.Group();
                    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2d3748, roughness: 0.4, metalness: 0.9 });
                    const torso = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 0.6), bodyMat);
                    torso.position.y = 1.5;
                    torso.castShadow = true;
                    enemyGroup.add(torso);
                    const head = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 8), bodyMat);
                    head.position.y = 2.5;
                    head.castShadow = true;
                    enemyGroup.add(head);
                    const createLimb = () => {
                        const limbGroup = new THREE.Group();
                        const upper = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.15, 0.8, 6), bodyMat);
                        upper.position.y = -0.4;
                        const lowerGroup = new THREE.Group();
                        const lower = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.12, 0.8, 6), bodyMat);
                        lower.position.y = -0.4;
                        lowerGroup.add(lower);
                        lowerGroup.position.y = -0.8;
                        limbGroup.add(upper);
                        limbGroup.add(lowerGroup);
                        limbGroup.upper = upper;
                        limbGroup.lower = lowerGroup;
                        upper.castShadow = true;
                        lower.castShadow = true;
                        return limbGroup;
                    };
                    const leftArm = createLimb(), rightArm = createLimb(), leftLeg = createLimb(), rightLeg = createLimb();
                    leftArm.position.set(-0.7, 2.1, 0);
                    rightArm.position.set(0.7, 2.1, 0);
                    leftLeg.position.set(-0.3, 0.75, 0);
                    rightLeg.position.set(0.3, 0.75, 0);
                    enemyGroup.add(leftArm, rightArm, leftLeg, rightLeg);
                    enemyGroup.userData = { limbs: { leftArm, rightArm, leftLeg, rightLeg }, animationTime: Math.random() * Math.PI * 2, isMoving: false, health: 100 };
                    enemyGroup.position.set(Math.random() * 600 - 300, 0, Math.random() * 600 - 300);
                    this.state.enemies.push(enemyGroup);
                    this.state.scene.add(enemyGroup);
                }
            }
            
            createPlayerWeaponModel(type) {
                const group = new THREE.Group();
                const darkMat = new THREE.MeshStandardMaterial({ color: 0x1a202c, roughness: 0.3, metalness: 0.9 });
                const greyMat = new THREE.MeshStandardMaterial({ color: 0x4a5568, roughness: 0.5, metalness: 0.8 });
                const handMat = new THREE.MeshStandardMaterial({ color: 0x2d3748, roughness: 0.6 });

                const weapon = new THREE.Group();
                const receiver = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.2, 0.15), darkMat);
                weapon.add(receiver);
                const handguard = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.15, 0.15), greyMat);
                handguard.position.set(0.7, 0, 0);
                weapon.add(handguard);
                const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.4, 8), darkMat);
                barrel.rotation.x = Math.PI / 2;
                barrel.position.set(1.3, 0, 0);
                weapon.add(barrel);
                const stockBase = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.1, 0.1), greyMat);
                stockBase.position.set(-0.5, 0.05, 0);
                weapon.add(stockBase);
                const stockEnd = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.3, 0.1), darkMat);
                stockEnd.position.set(-0.65, -0.05, 0);
                weapon.add(stockEnd);
                const grip = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.5, 0.15), darkMat);
                grip.position.set(-0.1, -0.25, 0);
                grip.rotation.z = 0.2;
                weapon.add(grip);
                const mag = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.5, 0.2), greyMat);
                mag.position.set(0.2, -0.3, 0);
                mag.rotation.z = -0.1;
                weapon.add(mag);
                const sightBase = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.1), darkMat);
                sightBase.position.set(0.2, 0.15, 0);
                weapon.add(sightBase);
                const sightScreen = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.2, 0.2), greyMat);
                sightScreen.position.set(0.25, 0.2, 0);
                weapon.add(sightScreen);
                
                const hands = new THREE.Group();
                const rightHand = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.4), handMat);
                rightHand.position.set(-0.1, -0.25, 0.1);
                rightHand.rotation.z = 0.2;
                hands.add(rightHand);
                const leftHand = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.4), handMat);
                leftHand.position.set(0.7, -0.05, 0.1);
                hands.add(leftHand);
                
                group.add(weapon);
                group.add(hands);
                
                group.position.set(0.3, -0.3, -0.7);
                group.rotation.y = Math.PI/2 + 0.1;
                group.scale.set(0.8, 0.8, 0.8);

                return group;
            }

            animate() {
                this.state.animationFrameId = requestAnimationFrame(() => this.animate());
                const delta = Math.min(this.state.clock.getDelta(), 0.1);
                
                this.updatePlayer(delta);
                this.updateBullets(delta);
                this.updateEnemies(delta);
                this.updateHUD();

                if (this.state.snowParticles) {
                    this.state.snowParticles.rotation.y += delta * 0.1;
                    const positions = this.state.snowParticles.geometry.attributes.position.array;
                    for (let i = 1; i < positions.length; i += 3) {
                        positions[i] -= 10 * delta;
                        if (positions[i] < -250) positions[i] = 250;
                    }
                    this.state.snowParticles.geometry.attributes.position.needsUpdate = true;
                }

                if (this.state.weaponModel) {
                    const time = this.state.clock.getElapsedTime();
                    const isMoving = (this.state.keys['KeyW'] || this.state.keys['KeyS'] || this.state.keys['KeyA'] || this.state.keys['KeyD']);
                    const bobSpeed = this.state.keys['ShiftLeft'] ? 14 : 8;
                    const bobAmount = isMoving ? 0.02 : 0.005;
                    this.state.weaponModel.position.y = -0.3 + Math.sin(time * bobSpeed) * bobAmount;
                    this.state.weaponModel.position.x = 0.3 + Math.cos(time * bobSpeed * 0.5) * bobAmount * 0.5;
                }

                this.state.renderer.render(this.state.scene, this.state.camera);
            }

            updatePlayer(delta) {
                if (isMobile) {
                    const euler = new THREE.Euler(0, 0, 0, 'YXZ');
                    euler.setFromQuaternion(this.state.camera.quaternion);
                    euler.y -= this.state.touchLook.x * 0.002;
                    euler.x -= this.state.touchLook.y * 0.002;
                    euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
                    this.state.camera.quaternion.setFromEuler(euler);
                    this.state.touchLook.x = 0;
                    this.state.touchLook.y = 0;
                }

                if (!isMobile && (!this.state.controls || !this.state.controls.isLocked)) return;
                
                const speed = (this.state.keys['ShiftLeft'] ? 8.0 : 5.0) * delta;
                
                const moveForward = (this.state.keys['KeyW'] || this.state.keys['ArrowUp']) ? 1 : 0;
                const moveBackward = (this.state.keys['KeyS'] || this.state.keys['ArrowDown']) ? 1 : 0;
                const moveLeft = (this.state.keys['KeyA'] || this.state.keys['ArrowLeft']) ? 1 : 0;
                const moveRight = (this.state.keys['KeyD'] || this.state.keys['ArrowRight']) ? 1 : 0;
                
                const forwardDistance = (moveForward - moveBackward) * speed;
                const rightDistance = (moveRight - moveLeft) * speed;

                if (!isMobile) {
                    this.state.controls.moveForward(forwardDistance);
                    this.state.controls.moveRight(rightDistance);
                } else {
                    const direction = new THREE.Vector3();
                    this.state.camera.getWorldDirection(direction);
                    direction.y = 0;
                    direction.normalize();

                    const right = new THREE.Vector3().crossVectors(this.state.camera.up, direction);

                    this.state.player.position.add(direction.multiplyScalar(forwardDistance));
                    this.state.player.position.add(right.multiplyScalar(rightDistance));
                }
            }
            
            updateBullets(delta) {
                 for (let i = this.state.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.state.bullets[i];
                    if(!bullet || !bullet.mesh) continue;
                    bullet.mesh.position.add(bullet.velocity.clone().multiplyScalar(delta));
                    bullet.life -= delta;
                    for (let j = this.state.enemies.length - 1; j >= 0; j--) {
                        const enemy = this.state.enemies[j];
                        if (bullet.mesh.position.distanceTo(enemy.position) < 2.5) { 
                            enemy.userData.health -= 35;
                            
                            enemy.traverse(child => { if(child.isMesh) child.material.emissive.setHex(0xffffff) });
                            setTimeout(() => enemy.traverse(child => { if(child.isMesh) child.material.emissive.setHex(0x000000) }), 100);

                            if (enemy.userData.health <= 0) {
                                this.state.scene.remove(enemy);
                                this.state.enemies.splice(j, 1);
                                this.state.remainingEnemies--;
                                if(this.state.remainingEnemies <= 0) this.endGameCallback(true, this.state.playerHealth);
                            }
                            this.state.scene.remove(bullet.mesh);
                            this.state.bullets.splice(i, 1);
                            break; 
                        }
                    }
                    if (bullet && bullet.life <= 0) {
                        if(this.state.scene) this.state.scene.remove(bullet.mesh);
                        this.state.bullets.splice(i, 1);
                    }
                }
            }
            
            updateEnemies(delta) {
                this.state.enemies.forEach(enemy => {
                    const distanceToPlayer = enemy.position.distanceTo(this.state.player.position);
                    enemy.userData.isMoving = false;

                    if (distanceToPlayer < 200) {
                        enemy.userData.isMoving = true;
                        const direction = new THREE.Vector3().subVectors(this.state.player.position, enemy.position).normalize();
                        
                        enemy.position.add(direction.clone().multiplyScalar(delta * 5));
                        const targetQuaternion = new THREE.Quaternion().setFromRotationMatrix(new THREE.Matrix4().lookAt(this.state.player.position, enemy.position, enemy.up));
                        enemy.quaternion.slerp(targetQuaternion, 0.1);

                        if (distanceToPlayer < 100 && Math.random() < 0.02) {
                            this.state.playerHealth -= 5;
                            if(this.state.playerHealth <= 0) this.endGameCallback(false, 0);
                        }
                    }
                    
                    const { leftArm, rightArm, leftLeg, rightLeg } = enemy.userData.limbs;
                    const animationSpeed = enemy.userData.isMoving ? 15 : 4;
                    const amplitude = enemy.userData.isMoving ? 1.0 : 0.2;
                    
                    enemy.userData.animationTime += delta * animationSpeed;
                    const swingAngle = Math.sin(enemy.userData.animationTime) * amplitude;
                    const kneeBend = Math.max(0, Math.cos(enemy.userData.animationTime * 2)) * 0.8;

                    leftLeg.rotation.x = swingAngle;
                    rightLeg.rotation.x = -swingAngle;
                    leftArm.rotation.x = -swingAngle;
                    rightArm.rotation.x = swingAngle;
                    
                    leftLeg.lower.rotation.x = -kneeBend;
                    rightLeg.lower.rotation.x = -kneeBend;
                });
            }

            shoot() {
                this.state.currentAmmo--;
                const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
                const direction = new THREE.Vector3();
                this.state.camera.getWorldDirection(direction);
                bullet.position.copy(this.state.player.position);
                bullet.velocity = direction.multiplyScalar(300);
                const bulletObj = {mesh: bullet, velocity: bullet.velocity, life: 5};
                this.state.bullets.push(bulletObj);
                this.state.scene.add(bulletObj.mesh);
                if (this.state.currentAmmo === 0) setTimeout(() => { if(this.state.renderer) this.state.currentAmmo = this.state.maxAmmo; this.updateHUD(); }, 1500);

                const recoilAmount = 0.03;
                this.state.weaponModel.position.z += recoilAmount;
                setTimeout(() => { if(this.state.weaponModel) this.state.weaponModel.position.z -= recoilAmount; }, 50);
            }

            updateHUD() {
                document.getElementById('health-display').innerText = `HP: ${Math.max(0, this.state.playerHealth)}`;
                document.getElementById('ammo-display').innerText = `Amunisi: ${this.state.currentAmmo} / ∞`;
                document.getElementById('enemy-display').innerText = `Musuh Tersisa: ${this.state.remainingEnemies}`;
            }

            addGameEventListeners() {
                this.onWindowResize = () => { if(this.state.camera) { this.state.camera.aspect = window.innerWidth / window.innerHeight; this.state.camera.updateProjectionMatrix(); this.state.renderer.setSize(window.innerWidth, window.innerHeight); }};
                window.addEventListener('resize', this.onWindowResize);

                if (isMobile) {
                    this.setupMobileControls();
                } else {
                    this.onKeyDown = (e) => { this.state.keys[e.code] = true; };
                    this.onKeyUp = (e) => { this.state.keys[e.code] = false; };
                    this.onMouseDown = (e) => { if (this.state.controls && this.state.controls.isLocked && this.state.currentAmmo > 0) this.shoot(); };
                    this.onLock = () => instructions.classList.add('hidden');
                    this.onUnlock = () => { if (this.state.playerHealth > 0 && this.state.remainingEnemies > 0) instructions.classList.remove('hidden'); };
                    
                    document.addEventListener('keydown', this.onKeyDown);
                    document.addEventListener('keyup', this.onKeyUp);
                    document.addEventListener('mousedown', this.onMouseDown);
                    if (this.state.controls) {
                        this.state.controls.addEventListener('lock', this.onLock);
                        this.state.controls.addEventListener('unlock', this.onUnlock);
                    }
                }
            }
            removeGameEventListeners() {
                 window.removeEventListener('resize', this.onWindowResize);
                 if (isMobile) {
                     // remove touch listeners here
                 } else {
                     document.removeEventListener('keydown', this.onKeyDown);
                     document.removeEventListener('keyup', this.onKeyUp);
                     document.removeEventListener('mousedown', this.onMouseDown);
                     if (this.state.controls) {
                        this.state.controls.removeEventListener('lock', this.onLock);
                        this.state.controls.removeEventListener('unlock', this.onUnlock);
                     }
                 }
            }
            setupMobileControls() {
                const joystickBase = document.querySelector('.joystick-base');
                const joystickNub = document.querySelector('.joystick-nub');
                const lookArea = document.getElementById('look-area');
                const shootBtn = document.getElementById('shoot-btn');
                const sprintBtn = document.getElementById('sprint-btn');
                
                joystickBase.addEventListener('touchstart', (e) => e.preventDefault(), { passive: false });
                joystickBase.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = joystickBase.getBoundingClientRect();
                    const dx = touch.clientX - (rect.left + rect.width / 2);
                    const dy = touch.clientY - (rect.top + rect.height / 2);
                    const distance = Math.min(50, Math.hypot(dx, dy));
                    const angle = Math.atan2(dy, dx);
                    
                    joystickNub.style.transform = `translate(${Math.cos(angle) * distance - 25}px, ${Math.sin(angle) * distance - 25}px)`;

                    this.state.keys['KeyW'] = dy < -15;
                    this.state.keys['KeyS'] = dy > 15;
                    this.state.keys['KeyA'] = dx < -15;
                    this.state.keys['KeyD'] = dx > 15;
                }, { passive: false });

                joystickBase.addEventListener('touchend', () => {
                    joystickNub.style.transform = 'translate(-25px, -25px)';
                    this.state.keys['KeyW'] = this.state.keys['KeyS'] = this.state.keys['KeyA'] = this.state.keys['KeyD'] = false;
                });
                
                lookArea.addEventListener('touchstart', (e) => {
                    const touch = e.touches[0];
                    this.state.touchLook.lastX = touch.clientX;
                    this.state.touchLook.lastY = touch.clientY;
                    this.state.touchLook.active = true;
                });
                lookArea.addEventListener('touchmove', (e) => {
                    if (!this.state.touchLook.active) return;
                    const touch = e.touches[0];
                    this.state.touchLook.x = touch.clientX - this.state.touchLook.lastX;
                    this.state.touchLook.y = touch.clientY - this.state.touchLook.lastY;
                    this.state.touchLook.lastX = touch.clientX;
                    this.state.touchLook.lastY = touch.clientY;
                });
                lookArea.addEventListener('touchend', () => this.state.touchLook.active = false);

                let shootInterval = null;
                shootBtn.addEventListener('touchstart', () => {
                    if (!shootInterval) shootInterval = setInterval(() => this.shoot(), 100);
                });
                shootBtn.addEventListener('touchend', () => {
                    clearInterval(shootInterval);
                    shootInterval = null;
                });

                sprintBtn.addEventListener('touchstart', () => this.state.keys['ShiftLeft'] = true);
                sprintBtn.addEventListener('touchend', () => this.state.keys['ShiftLeft'] = false);
            }
        }

        // --- Main Application Logic ---
        const AppManager = {
            db: null,
            auth: null,
            appId: typeof __app_id !== 'undefined' ? __app_id : 'default-app-id',
            currentGame: null,
            selectedCharacter: 'Assault',
            selectedMap: 'forest',
            previewAnimationId: null,

            nodes: {
                loginScreen: document.getElementById('login-screen'),
                startMenu: document.getElementById('start-menu'),
                gameOverScreen: document.getElementById('game-over-screen'),
                authError: document.getElementById('auth-error'),
                hud: document.getElementById('hud'),
                crosshair: document.getElementById('crosshair'),
                instructions: document.getElementById('instructions'),
                mobileControls: document.getElementById('mobile-controls'),
                playerId: document.getElementById('player-id'),
                emailInput: document.getElementById('email-input'),
                passwordInput: document.getElementById('password-input'),
            },

            init() {
                this.initializeFirebase();
                this.bindUIEvents();
                if (isMobile) {
                    this.nodes.mobileControls.classList.remove('hidden');
                }
            },

            initializeFirebase() {
                const app = initializeApp(firebaseConfig);
                this.db = getFirestore(app);
                this.auth = getAuth(app);
                onAuthStateChanged(this.auth, user => this.onAuthStateChange(user));
            },

            onAuthStateChange(user) {
                if (user) {
                    this.nodes.playerId.innerText = user.email;
                    this.nodes.loginScreen.classList.add('hidden');
                    this.nodes.startMenu.classList.remove('hidden');
                    this.fetchLeaderboard();
                    // this.setupCharacterPreviews(); // Removed for stability
                } else {
                    this.nodes.loginScreen.classList.remove('hidden');
                    this.nodes.startMenu.classList.add('hidden');
                    if (this.previewAnimationId) cancelAnimationFrame(this.previewAnimationId);
                }
            },

            bindUIEvents() {
                document.getElementById('login-btn').addEventListener('click', () => this.login());
                document.getElementById('register-btn').addEventListener('click', () => this.register());
                document.getElementById('main-logout-btn').addEventListener('click', () => signOut(this.auth));

                document.getElementById('start-game-btn').addEventListener('click', () => this.startGame());
                document.getElementById('restart-btn').addEventListener('click', () => this.returnToMenu());

                document.querySelectorAll('.character-card').forEach(card => card.addEventListener('click', (e) => {
                    document.querySelectorAll('.character-card').forEach(c => c.classList.remove('selected'));
                    const selectedCard = e.currentTarget;
                    selectedCard.classList.add('selected');
                    this.selectedCharacter = selectedCard.id.split('-')[1];
                }));
                document.querySelectorAll('.map-btn').forEach(btn => btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.map-btn').forEach(b => { b.className = b.className.replace(/border-(green|gray|blue)-500/, 'border-transparent'); });
                    const selectedBtn = e.currentTarget;
                    const map = selectedBtn.id.split('-')[1];
                    selectedBtn.classList.remove('border-transparent');
                    selectedBtn.classList.add(`border-${map === 'forest' ? 'green' : map === 'city' ? 'gray' : 'blue'}-500`);
                    this.selectedMap = map;
                }));
            },

            async login() {
                this.nodes.authError.innerText = '';
                try {
                    await signInWithEmailAndPassword(this.auth, this.nodes.emailInput.value, this.nodes.passwordInput.value);
                } catch (e) {
                    this.nodes.authError.innerText = e.message;
                }
            },

            async register() {
                this.nodes.authError.innerText = '';
                try {
                    await createUserWithEmailAndPassword(this.auth, this.nodes.emailInput.value, this.nodes.passwordInput.value);
                } catch (e) {
                    this.nodes.authError.innerText = e.message;
                }
            },

            startGame() {
                if (this.previewAnimationId) cancelAnimationFrame(this.previewAnimationId);
                this.nodes.startMenu.classList.add('hidden');
                this.nodes.hud.classList.remove('hidden');
                this.nodes.crosshair.classList.remove('hidden');
                this.currentGame = new GameEngine((isWin, health) => this.handleEndGame(isWin, health));
                this.currentGame.start(this.selectedMap, this.selectedCharacter);
            },

            returnToMenu() {
                this.nodes.gameOverScreen.classList.add('hidden');
                this.nodes.startMenu.classList.remove('hidden');
                this.fetchLeaderboard();
                // this.setupCharacterPreviews(); // Removed for stability

                const gameOverText = this.nodes.gameOverScreen.querySelector('h1');
                gameOverText.innerText = "GAME OVER";
                gameOverText.classList.replace('text-green-500', 'text-red-500');
                this.nodes.gameOverScreen.querySelector('p').innerText = "Kamu telah dikalahkan.";
            },

            handleEndGame(isWin, finalHealth) {
                if (this.currentGame) {
                    this.saveScore(finalHealth);
                    this.currentGame.destroy();
                    this.currentGame = null;
                }
                
                ['hud', 'crosshair', 'instructions'].forEach(id => document.getElementById(id).classList.add('hidden'));

                if (isWin) {
                    const gameOverText = this.nodes.gameOverScreen.querySelector('h1');
                    gameOverText.innerText = "KAMU MENANG!";
                    gameOverText.classList.replace('text-red-500', 'text-green-500');
                    this.nodes.gameOverScreen.querySelector('p').innerText = "Semua musuh telah dikalahkan. Skor tersimpan!";
                }
                this.nodes.gameOverScreen.classList.remove('hidden');
            },
            
            async fetchLeaderboard() {
                const list = document.getElementById('leaderboard-list');
                list.innerHTML = '<p>Memuat...</p>';
                try {
                    const q = query(collection(this.db, `artifacts/${this.appId}/public/data/scores`), limit(5));
                    const snapshot = await getDocs(q);
                    const scores = snapshot.docs.map(doc => doc.data()).sort((a,b) => b.score - a.score);
                    list.innerHTML = scores.length ? scores.map((s, i) => `<div class="flex justify-between p-2 rounded ${i%2===0?'bg-gray-800':'bg-gray-700/50'}"><span>${i+1}. ${s.userEmail.split('@')[0]}</span><span class="text-cyan-300">${s.score} Poin</span></div>`).join('') : '<p>Belum ada skor.</p>';
                } catch(e) { console.error(e); list.innerHTML = '<p class="text-red-500">Gagal memuat.</p>'; }
            },

            async saveScore(score) {
                if (!this.auth.currentUser) return;
                const scoreData = {
                    userId: this.auth.currentUser.uid, userEmail: this.auth.currentUser.email,
                    character: this.selectedCharacter, map: this.selectedMap, score: score,
                    createdAt: new Date()
                };
                try { await addDoc(collection(this.db, `artifacts/${this.appId}/public/data/scores`), scoreData); } 
                catch (e) { console.error("Error saving score: ", e); }
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            AppManager.init();
        });
    </script>
</body>
</html>

